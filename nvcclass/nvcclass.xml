<chapter short="Automatic Classification of NVC" title="Automatic Classification of NVC in Spontaneous Conversation" label="ChapterClassification" label2="SectionClassificationIntro">
<quote>
Computers are useless. They can only give you answers.<br/>
Pablo Picasso
</quote>

<p>This chapter describes a study of automatic recognition of natural <ac>NVC</ac> in informal conversations. To find the features and classifier best suited for this task, a comparison between various alternative components of the recognition system is performed. The automatic system uses the naturalistic <ac>NVC</ac> corpus described in the previous chapter.
This thesis only considers visual information, because it is an important mode for <ac>NVC</ac>. Although the exact modality distribution of each <ac>NVC</ac> is not well documented in the literature, possibly due to the enormity of such a task, this study focuses on facial behaviour because it is obviously a very significant modality for <ac>NVC</ac><footnote>“In fact, some researchers believe the primary function of the face is to communicate, not to express emotions.” <cite ref='Knapp2009'/>, p. 9</footnote>. However, other non-facial behaviours are thought to play a significant role in the expression of <ac>NVC</ac>. Also, it is well known that the non-verbal component of voice contains sufficient information to recognise emotion.
It is likely that a hybrid approach using visual and audio information would be an effective approach for <ac>NVC</ac> recognition.</p>

<p>Because the TwoTalk corpus is used for training, this is one of the first automatic <ac>NVC</ac> recognition systems to operate on informal conversation <footnote>The existing AMI corpus contains informal conversation and has been used for automatic recognition but the labels used generally do not address <ac>NVC</ac> specifically.</footnote>. It is also one of the first to recognise human behaviour outside of a task based, role play based or otherwise specialised situation <footnote>Again, some studies have used the informal part of the AMI corpus has been addressed, but often these studies also consider the acted data as they are part of the same data set.</footnote>. 
This chapter only uses clear samples of <ac>NVC</ac>, while intermediate intensity samples are discarded (this is discussed in detail in Section <ref label='SectionClearExamples'/>). This simplifies the recognition task and makes the work similar to some previous studies which use strong acted emotion, while retaining the naturalistic quality of the data. However, a practical system should also operate on intermediate intensity <ac>NVC</ac>; this issue is considered in Chapter <ref label='ChapterNvcRegression'/>.
There are only a few previous studies of automatic <ac>NVC</ac> recognition, with agreement and disagreement being the most popular. 
The annotation labels used in this thesis are <i>agree</i>, <i>thinking</i>, <i>question</i> and <i>understand</i>.</p>

<p>The primary contributions of this chapter are:</p>

<ul>
<li>A study of automatic <ac>NVC</ac> classification of clear, naturalistic samples in informal conversation. Different approaches to <macro v='featureGeneration'/> and classification are compared.</li>
<li>Visualisation and analysis of <i>thinking</i> <ac>NVC</ac> in a simplified feature space based on eye movements, to determine the presence of any consistent behavioural patterns.</li>
<li>An analysis of classification performance for specific types of <ac>NVC</ac> signals, to find their relative recognition difficulties.</li>
</ul>

<p>The following section provides an overview of existing classification techniques. Section <ref label='SectionClassificationOverview'/> provides a broad overview of the automatic system. Section <ref label='SectionFeatureGeneration'/> explains the various <macro v='featureGeneration'/> methods used in the comparison. Various <macro v='featureGeneration'/> methods are compared to determine the best approach. Section <ref label='SectionClassificationMethods'/> describes the classifiers used in the comparison. The selection of clips for training and testing from the corpus is described in Section <ref label='SectionClearExamples'/>. Performance measurement is detailed in Section <ref label='SectionClassificationPerformance'/>. The performance of various features and classifiers is shown and discussed in Section <ref label='SectionNvcClassificationResults'/>. The use of polynomial curves to encode temporal variations is examined in Section <ref label='SectionTemporalFeatures'/>. An exploration of <i>thinking</i> in a simplified feature space is conducted in Section <ref label='SectionVisualisingGaze'/>. Work by Akakın and Sankur <cite ref='Akakin2011'/> that builds upon the work of this chapter is discussed in Section <ref label='SectionHmm'/>.</p>

<section title="Overview" label="SectionClassificationOverview">

<figure caption="An overview of the automatic &lt;ac&gt;NVC&lt;/ac&gt; classification system.">
<grahpic width="0.6">nvcclass/classSystemOverview.pdf</grahpic>
</figure>

<p>This chapter describes an automatic <ac>NVC</ac> classification system and evaluates its performance. 
The basic steps are shown in Figure <ref label='FigureClassificationOverview'/>. Corpus data is split into cross validation folds of seen training data and unseen test data. 
Various <macro v='featureGeneration'/> techniques are used as the baseline for a comparison of different approaches. The features are then used to train either an <ac>SVM</ac> or Adaboost model. The model is used to predict labels on test data, on which the appropriate <macro v='featureGeneration'/> technique has been applied. The predicted labels are compared to annotator ratings and the performance is evaluated.</p>

<p>The next section describes the issues in converting the original videos into suitable features for supervised learning.</p>

</section>
<section title="&lt;macro v='FeatureGenerationTitle'/&gt;" label="SectionFeatureGeneration">

<p>This chapter describes several different <macro v='featureGeneration'/> approaches and compares their performance for &lt;ac&gt;NVC&lt;/ac&gt; classification.
<macro v='FeatureGeneration'/> takes raw input frames and produces a feature representation that is intended to increase the robustness to changes in the raw input data that are not significant for the application.
The irrelevant changes include:</p>

<ul>
<li>identity and face shape,</li>
<li>lighting changes,</li>
<li>head rotation and translation, although it is useful to have this encoded separately from emotion and not entirely discarded and</li>
<li>occlusions.</li>
</ul>

<p>Existing feature extraction techniques have previously been discussed in Section <ref label='BackgroundEncodeFacialInfo'/>. There are a wide range of possible approaches to facial <macro v='featureGeneration'/> and the choice of features in previous works are largely experimentally driven to achieve accuracy on a chosen data set. However, there are a few properties of naturalistic <ac>NVC</ac> that make this task distinct from many posed behaviour based studies. Naturalistic behaviour is harder to recognise than posed examples <cite ref='Cohn2004b'/>, probably due to the differences in the way emotions are expressed in these situations, as well as the amount of head pose present in the data. These large pose changes make some approaches unsuitable for natural <ac>NVC</ac> recognition. For this reason, <ac>AAM</ac>s were not used because, in their basic formulation, they are not robust to large head pose changes <cite ref='Sung2008'/>. Also, large head pose changes cause significant changes in facial appearance <cite ref='Lu2006'/> and normalising face appearance to frontal pose is difficult, requiring image completion or texture synthesis to replace self-occluded parts of the face <cite ref='Asthana2011'/>. These factors are likely to make appearance based features less suitable for this task. The effect of large pose changes can be mitigated by the use of a multi-camera recording, but this is a more involved experimental arrangement which limits this approach to fewer practical applications. For these reasons, this study primarily focuses on facial shape recorded using a simple camera. It is assumed that by using the visual modality, only non-verbal communication will be used as the basis for recognition. In principle, it is possible for an automatic system to learn the verbal component of communication via speech reading. However, given the extreme difficulty of speech reading <cite ref='Ong2011'/>, this is not a significant factor in the context of this study. The strengths and weaknesses of the methods employed are discussed in the next few sections.</p>

<p>The names of the <macro v='featureGeneration'/> approaches have been abbreviated for the sake of convenience: <i>affine</i> refers to affine head pose estimation, <i>deform-cubica</i> refers to tracking deformations based in CubICA, <i>deform-fastica</i> refers to tracking deformations based on FastICA, <i>deform-pca</i> refers to tracking deformations based on PCA, <i>geometric-h</i> refers to heuristic geometric features, <i>geometric-a</i> refers to algorithmic geometric features, <i>lbp</i> refers to local binary patterns and <i>lma</i> refers to head pose estimation by <ac full='yes'>LMA</ac> model fitting.</p>

<subsection title="Linear Predictor Feature Tracking for Facial Analysis" label="SectionLpTracking">

<figure caption="Illustration of position of LP Trackers on facial features." label="FigureTrackerPositions">
<graphic width="0.6">nvcclass/TrackerPositions.pdf</graphic>
</figure>

<p><ac>LP</ac> feature tracking <cite ref='Ong2009'/> was applied to unconstrained natural conversation videos. This method was selected because it is relatively robust to head pose changes. The theory for this method is discussed in Appendix <ref label='BackgroundLpTracking'/> and is used instead of the more common trackers, such as <ac>KLT</ac> <cite ref='Tomasi1991'/>. Both methods store pixel intensity information for a region near a feature point of interest. However, the <ac>KLT</ac> feature tracker uses a single training template as a model, while <ac>LP</ac>s use a model based on one or more training frames. For this reason, an  <ac>LP</ac> tracker requires more manual interaction by an operator to create suitable training data. However, the use of multiple appearances from multiple frames enables an <ac>LP</ac> to generalise to multiple poses.</p>

The number and location of the trackers was based on balancing the need to: 
<ul>
<li>encode as much shape information of the face as possible,</li>
<li>the need to be able to reliably specify the position on multiple frames (due to multiple frame training being supported by <ac>LP</ac>s) and</li>
<li>the resources needed to create the tracker training data.</li>
</ul>

<p>The $<macro v='numTrackers'/>$ points on the face that were selected to be tracked are shown in Figure <ref label='FigureTrackerPositions'/>. The positions were manually initialised at the start of each of the 12 minute videos. The tracker then predicted the feature position on each subsequent frame. Point correspondence was maintained between the eight subjects in the corpus to enable inter-person comparison. Due to extreme head motion or occlusions, the tracker occasionally suffered unacceptable levels of drift and was manually re-positioned on the correct feature location. The resultant tracking positions for $<macro v='numTrackers'/>$ trackers on a single frame are designated $<macro v='rawTracking'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numTrackers'/> <macro v='times'/> 2}, <macro v='numTrackers'/> <macro v='in'/> <mathbb>N</mathbb>$</p>

</subsection>
<subsection title="Heuristic Geometric Features" label="SectionGenerateHeuristic">

<p>Some <macro v='featureGeneration'/> methods attempt to comprehensively encode the overall face deformation in an unsupervised fashion, but these are not necessarily optimal for classification. An alternative approach is to manually engineer a set of features that correspond to local facial deformations. The relevant areas of the face are manually selected based on experience of what is likely to be relevant information to perform classification. These features are referred to as “heuristic geometric” features, abbreviated to <i>geometric-h</i>. The specific feature set used was inspired by el Kaliouby and Robinson's manually engineered features <cite ref='Kaliouby2005'/> (see Table <ref label='TableHeuristicFeaturesComparison'/> for a comparison). They primarily use shape information from tracking, as well as additional appearance features to find the mouth aperture area and teeth visibility. The approach presented here slightly differs in that it uses shape information only (see Table <ref label='GeometryFeaturesTable'/>). 
Additional features were added to encode eye gaze. 
Because the features correspond to muscle driven facial deformations, they are analogous to a subset of FACS action units <cite ref='Ekman1978'/>.
Heuristic features are computed based on LP tracker positions (shown in Figure <ref label='FigureHeuristicTrackers'/>) to form frame feature $<macro v='frameFeature'/>_{geometric-h} <macro v='in'/> <mathbb>R</mathbb>^{12}$.</p>

<figure caption="Illustration of position of LP Trackers used in the extraction of Heuristic Geometric Features." label="FigureHeuristicTrackers">
<graphic width="0.6">nvcclass/HeuristicTrackers.pdf</graphic>
</figure>

<table caption="Inter-Culture Correlation of Various Mean Filtered Culture Responses." label="TableHeuristicFeaturesComparison">
<tr><td>Heuristic </td><td> El Kaliouby and Robinson </td></tr>
<tr><td>Features </td><td> Features <cite ref='Kaliouby2005'/></td></tr>
<tr><td>Head yaw </td><td> Head yaw </td></tr>
<tr><td>Head pitch </td><td> Head pitch </td></tr>
<tr><td>Head roll </td><td> Head roll</td></tr>
<tr><td>Eyebrow raise </td><td> Eyebrow raise</td></tr>
<tr><td>Lip pull </td><td> Lip pull</td></tr>
<tr><td>Lips part </td><td> Lip pucker </td></tr>
<tr><td>Eye horizontal position (Right) </td><td> Lips part </td></tr>
<tr><td>Eye horizontal position (Left) </td><td> Jaw drop </td></tr>
<tr><td>Eye horizontal position (Mean) </td><td> Teeth visible </td></tr>
<tr><td>Eye vertical position (Right)  </td><td> </td></tr>
<tr><td>Eye vertical position (Left) </td><td> </td></tr>
<tr><td>Eye vertical position (Mean) </td><td> </td></tr>
</table>

<table short="Heuristic geometric features used to extract facial expression while being robust to pose." caption="Heuristic geometric features used to extract facial expression while being robust to pose. Position $A$ is the average position of the outer mouth trackers. $&lt;macro v='timeOffset'/&gt;$ is the current frame number. These features were inspired by el Kaliouby and Robinson &lt;cite ref='Kaliouby2005'/&gt;." label="GeometryFeaturesTable">
<tr><td>Head yaw </td><td> $#frac{<overline><macro v='rawTracking'/>_{9} <macro v='rawTracking'/>_{10}</overline>}{<overline><macro v='rawTracking'/>_{11} <macro v='rawTracking'/>_{12}</overline>}$ </td></tr>
<tr><td>Head pitch </td><td> $<macro v='rawTracking'/>_{4}[<macro v='timeOffset]'/> - <macro v='rawTracking'/>_{4}[<macro v='timeOffset-1]'/>$</td></tr>
<tr><td>Head roll </td><td> $<macro v='angle'/> <macro v='rawTracking'/>_{9} <macro v='rawTracking'/>_{11}$</td></tr>
<tr><td>Eyebrow raise </td><td> $#frac{(<overline><macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{21}</overline>+<overline><macro v='rawTracking'/>_{1}<macro v='rawTracking'/>_{17}</overline>+<overline><macro v='rawTracking'/>_{12}<macro v='rawTracking'/>_{23}</overline>)_{t}}{(<overline><macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{21}</overline>+<overline><macro v='rawTracking'/>_{1}<macro v='rawTracking'/>_{17}</overline>+<overline><macro v='rawTracking'/>_{12}<macro v='rawTracking'/>_{23}</overline>)_{0}}$</td></tr>
<tr><td>Lip pull/pucker </td><td> $#frac{(<overline>A<macro v='rawTracking'/>_{7}</overline>+<overline>A<macro v='rawTracking'/>_{8}</overline>)_{t}-(<overline>A<macro v='rawTracking'/>_{7}</overline>+<overline>A<macro v='rawTracking'/>_{8}</overline>)_{0}}{(<overline>A<macro v='rawTracking'/>_{7}</overline>+<overline>A<macro v='rawTracking'/>_{8}</overline>)_{0}}$ </td></tr>
<tr><td>Lips part </td><td> $<overline><macro v='rawTracking'/>_{26} <macro v='rawTracking'/>_{28}</overline> <macro v='cdot'/> <overline><macro v='rawTracking'/>_{25} <macro v='rawTracking'/>_{27}</overline>$ </td></tr>
<tr><td>Right eye horizontal </td><td> $#frac{<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='cdot'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}}{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}|}$</td></tr>
<tr><td>Left eye horizontal </td><td> $#frac{<macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{10}<macro v='cdot'/> <macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{2}}{|<macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{10}|}$</td></tr>
<tr><td>Mean eye horizontal </td><td> $#frac{(<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='cdot'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}) (<macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{10}<macro v='cdot'/> <macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{2})}{2|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}||<macro v='rawTracking'/>_{9}<macro v='rawTracking'/>_{10}|}$</td></tr>
<tr><td>Right eye vertical </td><td> $#frac{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='times'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}|}{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}|}$ </td></tr>
<tr><td>Left eye vertical </td><td> $#frac{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='times'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}|}{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}|}$ </td></tr>
<tr><td>Mean eye vertical </td><td> $#frac{|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='times'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}| |<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}<macro v='times'/> <macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{1}|}{2|<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}||<macro v='rawTracking'/>_{11}<macro v='rawTracking'/>_{12}|}$</td></tr>
<tr><td>Mouth centre </td><td> $A=<overline>[<macro v='rawTracking'/>_{5},<macro v='rawTracking'/>_{6},<macro v='rawTracking'/>_{7},<macro v='rawTracking'/>_{8},<macro v='rawTracking'/>_{13},<macro v='rawTracking'/>_{14},<macro v='rawTracking'/>_{15},<macro v='rawTracking'/>_{16}]</overline>$</td></tr>
</table>

<p>Heuristic features focus on only a subset of facial deformations. The next section describes a method to encoding a broader range of face deformations.</p>

</subsection>
<subsection title="Algorithmic Geometric Features" label="SectionGenerateAlgorithmic">

<p>Manually engineered features encode a subset of facial deformations that are thought to be relevant by their designer. An alternative is to comprehensively encode the shape information of the facial feature trackers. 
Frame features are exhaustively generated based on a simple geometric measure. This approach is referred to as algorithmic geometric features, abbreviated to <i>geometric-a</i>. Ideally, this would encode information pertaining to local deformations of the face in separate features than motion due to head pose changes. Simple distances between pairs of trackers are used (see Figure <ref label='FigureAlgorithmicFeatures'/>), in a similar fashion to Valstar <macro v='etal'/> <cite ref='Valstar2006'/>. The length of the feature vector $<macro v='frameFeature'/>_{geometric-a}$, for $<macro v='numTrackers'/>$ trackers, is triangular number $T_{<macro v='numTrackers'/>}$ where $T_{<macro v='numTrackers'/>} = #frac{<macro v='numTrackers'/>(<macro v='numTrackers'/>+1)}{2}$. In this work, $<macro v='numTrackers'/>=46$ trackers are used to generate algorithmic features (see Figure <ref label='FigureTrackerPositions'/>), therefore $<macro v='frameFeature'/>_{geometric-a} <macro v='in'/> <mathbb>R</mathbb>^{T_{46}}=<mathbb>R</mathbb>^{1035}$. For two trackers of index $a <macro v='in'/> <mathbb>R</mathbb>$ and $b <macro v='in'/> \{0...<macro v='numTrackers'/><macro v=''/>}$, where $1 <macro v='le'/> a &lt; b$, the distance is computed:</p>

eqn\begin{gather}
eqn\frameFeature_{unnormalised\_alg}^{a + b + T_{b-1}} = |\rawTracking_{a} - \rawTracking_{b}|
eqn\end{gather}

<p>Although these feature components encode shape information from localised areas of the face, the features tend to include redundant information and are not robust to scale changes.</p>

<figure caption="A trivial example of how algorithmic geometric features are calculated for 3 tracked points. Exhaustive distance pairs of trackers are calculated." label="FigureAlgorithmicFeatures">
<graphic width="0.5">nvcclass/algorithmic-features.pdf</graphic>
</figure>

<p>The features are then processed to reduce the effect of identity. This normalisation is not applied to the other types of features (see Figure <ref label='FigureClassificationOverview'/>), although later chapters have normalisation applied in a consistent fashion to avoid this problem. Each feature component is rescaled and zero centred. This removes shape information due to both identity and some types of expressivity by removing person specific differences in facial deformation magnitude. Information that relates to facial shape deformation, in terms of a difference from the average face, is retained. For a video sequence of $<macro v='numSeqFrames'/>$ frames, all frame feature vectors are concatenated into a frame feature matrix $<macro v='frameFeatureMatrix'/> <macro v='in'/> <mathbb>R</mathbb>^{1035 <macro v='times'/> <macro v='numSeqFrames'/>}, <macro v='numSeqFrames'/> <macro v='in'/> <mathbb>N</mathbb>$. The mean $<macro v='componentMean'/>$ and variance $<macro v='componentVariance'/>$ values of each feature component are used to normalise and zero centre the feature ($<macro v='componentVariance,'/> <macro v='componentMean'/> <macro v='in'/> <mathbb>R</mathbb>^{1035}, i <macro v='in'/> \{0...1035\}$, $t <macro v='in'/> \{0...<macro v='numSeqFrames'/><macro v=''/>}$):</p>

eqn\begin{gather}
eqn\label{EqnFeatureComponentMean}
eqn\componentMean^i = \frac{\displaystyle\sum\limits_{j=0}^{\numSeqFrames}{\frameFeatureMatrix_{unnormalised\_alg}^{i,j}}}{\numSeqFrames} \\
eqn\label{EqnFeatureComponentVar}
eqn\componentVariance^i = \frac{\displaystyle\sum\limits_{j=0}^{\numSeqFrames}{{\frameFeatureMatrix_{unnormalised\_alg}^{i,j}}^2}}{\numSeqFrames} - {\componentMean^i}^2 \\
eqn\label{EqnNormaliseFeatureRange}
eqn\frameFeatureMatrix_{geometric-a}^{i,t} = \frac{\frameFeatureMatrix_{unnormalised\_alg}^{i,t} - \componentMean^i}{\sqrt{\componentVariance^i}}
eqn\end{gather}

<p>$<macro v='frameFeatureMatrix'/>_{geometric-a}$ is easy to compute but it requires an existing set of frames covering the range of <ac>NVC</ac> signals to calculate the mean $<macro v='componentMean'/>$ and scaling factors $<macro v='componentVariance'/>$ used in normalisation. This makes the approach unsuitable for immediate <macro v='featureGeneration'/> of a previously unseen face.</p>

</subsection>
<subsection title="Tracking-based Features using PCA and ICA Dimensionality Reduction">

<p><ac>PCA</ac> and <ac>ICA</ac> can be used to separate information due to changes in pose from information due to local deformation. This is necessary because raw features from tracking contain translations and other movement information that is not necessarily relevant to <ac>NVC</ac> classification. Directly using raw features would result in poor recognition performance. These dimensionality reduction techniques subdivide a signal by projecting it on to a new set of basis vectors; the basis vectors in the case of <ac>PCA</ac> correspond to a particular overall deformation of the face. <ac>PCA</ac> selects eigenvectors that are the largest orthogonal modes of variation, while <ac>ICA</ac> selects basis vectors that are statistically independent. The use of <ac>PCA</ac> on tracking data has previously been used by Lien <macro v='etal'/> <cite ref='Lien1998'/>.
The basis eigenvectors are learned in an unsupervised fashion but generally do not correspond to local areas of the face, nor guarantee that they are optimal for recognition.</p>

<p>For $<macro v='numTrackers'/>$ trackers, the positions on a single frame is designated as $<macro v='rawTracking'/> <macro v='in'/> <mathbb>R</mathbb>^{2 <macro v='times'/> <macro v='numTrackers'/>}$. For a video of $<macro v='numSeqFrames'/>$ frames, the tracking data is reshaped into a $2<macro v='numTrackers'/> <macro v='times'/> <macro v='numSeqFrames'/>$ matrix. This tracking matrix is zero centred to form matrix $<macro v='normalisedTracking'/>$. Performing <ac>PCA</ac> on $<macro v='normalisedTracking'/>$ produces $2<macro v='numTrackers'/>$ principal components. Each frame was then projected on to these basis vectors to form a frame feature $<macro v='frameFeature'/>_{pca} <macro v='in'/> <mathbb>R</mathbb>^{2<macro v='numTrackers'/>}$. A similar procedure was used to project frames into <ac>ICA</ac> space. Two specific <ac>ICA</ac> implementations were used: FastICA <cite ref='Hyvarinen1999'/> and CuBICA <cite ref='Blaschke2004'/>. FastICA is advantageous because of its fast convergence, while CuBICA is able to separate asymmetrically distributed sources but at a higher computational cost <cite ref='Wang05'/>. The frame feature corresponding to these methods are referred to as $<macro v='frameFeature'/>_{fastica}$ and $<macro v='frameFeature'/>_{cubica}$ respectively.</p>

</subsection>
<subsection title="&lt;ac&gt;LMA&lt;/ac&gt; Head Pose Estimation">

<p>The shape deformation of the face has been considered, but appearance information may also contribute to <ac>NVC</ac> recognition. For example, the appearance of wrinkles or the teeth cannot be effectively tracked due to their transitory appearance. To make comparisons between different frames and persons, the faces need to be aligned. This enables direct comparison of corresponding positions for the purposes of <ac>NVC</ac> recognition.</p>

<p>Head pose may be estimated by model fitting and cost minimisation. Cost minimisation is performed by minimising least square errors by <ac full='yes'>LMA</ac>, and a simple head model based on an average head shape and expressed in homogeneous coordinates ${<macro v='headMeshPos'/>} <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numTrackers'/> <macro v='times'/> 4}$. This is similar to the approach used by Liu and Zhang <cite ref='Liu2000'/>, but the head model is simplified to ignore the effect of expression. The model fitting results in estimates for 3 translation components and 3 Euler rotation components. 
Because of the simplicity of the model, it cannot encode facial expression but it does encode head pose information in an intuitive way. For example, head nodding and shaking are encoded as two distinct components. For each frame, the head post model error $<macro v='modelFitError'/>$ is estimated as follows:</p>

eqn\begin{gather}
eqn\modelFitError(\headRotation,\headTranslation) = \displaystyle\sum_{i=1}^{\numTrackers} { ||{\rawTracking}_{i} - \projFunc(\headRotation \headMeshPos_i + \headTranslation)||^2 }
eqn\label {LmPoseEquation}
eqn\end{gather}

<p>Where $<macro v='projFunc'/>$ is the perspective projection function, $<macro v='headTranslation'/>$ is the translation (where $<macro v='headRotation'/> <macro v='in'/> <mathbb>R</mathbb>^{4 <macro v='times'/> 4}$ is the head rotation matrix corresponding to the Euler angles {$<macro v='headRotation'/>_{pitch}$, $<macro v='headRotation'/>_{roll}$, $<macro v='headRotation'/>_{yaw}$} and $<macro v='headTranslation'/> <macro v='in'/> <mathbb>R</mathbb>^{4}$ is the head translation $<macro v='headTranslation'/>=\{<macro v='headTranslation'/>_x, <macro v='headTranslation'/>_y, <macro v='headTranslation'/>_z, 1.\}$). The pose parameters are varied to find the minimum model fit error. The pose variables $<macro v='headRotation'/>_{pitch}$, $<macro v='headRotation'/>_{roll}$, $<macro v='headRotation'/>_{yaw}$ and $<macro v='headTranslation'/>_x, <macro v='headTranslation'/>_y, <macro v='headTranslation'/>_z$ are concatenated to form a frame feature $<macro v='frameFeature'/>_{lma} <macro v='in'/> <mathbb>R</mathbb>^{6}$.</p>

</subsection>
<subsection title="Affine Head Pose Estimation">

<figure caption="An affine transform is calculated to transform the current face on to the frontal face shape. This diagram has been simplified to only use 7 tracked features." label="FigureAffineHeadPose">
<graphic width="0.5">nvcclass/affine-transform.pdf</graphic>
</figure>

<p>If the tracking positions $<macro v='rawTracking'/>$ are re-expressed as the homogeneous coordinate matrix ${<macro v='rawTrackingHomog'/>} <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numTrackers'/> <macro v='times'/> 3}$, an affine transform of tracker positions $<macro v='rawTrackingHomog'/>$ to another frontal reference shape $<macro v='rawTrackingHomog'/>'$ encodes the head pose.
The affine transform can also be used to align the face, but the affine transform approximation breaks down as the face rotates away from the frontal view.
The affine transform $<macro v='approxaffine'/> <macro v='in'/> <mathbb>R</mathbb> ^ {3 <macro v='times'/> 3}$ can be estimated by taking the matrix Moore-Penrose pseudo-inverse ($<macro v='rawTrackingHomog'/>^{+}$) as shown in Equation <ref label='AffineEquation'/>. The result can be reshaped to a frame vector vector $<macro v='frameFeature'/>_{affine} <macro v='in'/> <mathbb>R</mathbb> ^ {6}$.</p>

eqn\begin{gather}
eqn\rawTrackingHomog' = \approxaffine \cdot \rawTrackingHomog \\
eqn\approxaffine = \rawTrackingHomog' \cdot \rawTrackingHomog^{+}
eqn\label {AffineEquation}
eqn\end{gather}

</subsection>
<subsection title="Uniform Local Binary Patterns">

<p>There are many possible approaches to encoding facial texture (see Section <ref label='BackgroundEncodeFacialInfo'/> for background). <ac full='yes'>LBP</ac> <cite ref='Ojala2002'/> is used in this work, because it has been shown to be effective in encoding facial texture for emotion recognition <cite ref='Shan2009'/>. <ac>LBP</ac> focuses on encoding texture information, often in grey-scale images. The role of colour is not considered in this work, because <ac>NVC</ac> based facial colour changes are relatively rare and are a subtle effect. Local binary patterns are based on comparisons between a central pixel intensity and the intensities of nearby pixels. The comparison is a single “greater than” or “less than or equal” binary choice. The local pixels are often arranged in a simple pattern, such as a circle or a series of concentric circles. In this work, the simplest <ac>LBP</ac> operator is used, which considers the eight pixels surrounding a central pixel (see Figure <ref label='FigureLbp'/>), denoted as $LBP_{(8,1)}$. Each combination of possible binary intensities is mapped into a code book. <ac>LBP</ac>s in a region of interest are then usually used to form a histogram of code words. Ojala <macro v='etal'/> <cite ref='Ojala2002'/> focused on <ac>LBP</ac>s that have, at most, two bitwise transition in the circle of pixels, which they termed “uniform”. These histogram features were found to be effective, while reducing the number of code words from 256 to 59. The histograms are normalised to remove the effect of the number of <ac>LBP</ac> samples. These histograms may be used as features for recognition. <ac>LBP</ac>s are computationally simple and are largely robust to illumination changes, because of the removal of the absolute difference intensity information. For the image intensity of eight pixels $f_i <macro v='in'/> <mathbb>R</mathbb> ^ {8}, i = \{0...7\}$ surround central pixel $f_c <macro v='in'/> <mathbb>R</mathbb>$, the pixel comparison vector $<macro v='lpbWord'/> <macro v='in'/> <mathbb>Z</mathbb> ^ {8}$ and <ac>LBP</ac> value $LBP_{(8,1)} <macro v='in'/> <mathbb>Z</mathbb>$ is computed as:</p>

eqn\begin{gather}
eqn\lpbWord(f_i-f_c) = \begin{cases} 1, &amp; f_i \ge f_c \\ 0, &amp; otherwise \end{cases}\\
eqn\diffblock{LBP_{(8,1)} = \displaystyle\sum\limits_{j=0}^7 \lpbWord(f_j - f_c)2^P}
eqn\end{gather}

<figure caption="The basic $LBP{(8,1)}$ operator. For each pixel, the adjacent pixels $f_i$ are thresholded $&lt;macro v='lpbWord'/&gt;$ and concatenated to form an &lt;ac&gt;LBP&lt;/ac&gt; code." label="FigureLbp">
<graphic width="0.8">nvcclass/lbpfigure.pdf</graphic>
</figure>

<p>The face region was subdivided into a grid of $<macro v='lbpgridwidth'/>$ by $<macro v='lbpgridheight'/>$ rectangles (similar to Feng <macro v='etal'/> <cite ref='Feng2005'/>, $<macro v='lbpgridwidth,'/> <macro v='lbpgridheight'/> <macro v='in'/> <mathbb>N</mathbb>$). The grid used the affine transform $<macro v='approxaffine'/>$, described in the previous section, to maintain the alignment with the underlying facial features. Uniform <ac>LBP</ac>s were calculated on each rectangle in the grid, producing $<macro v='lbpgridwidth'/><macro v='times'/><macro v='lbpgridheight'/>$ histograms. These histograms were concatenated into a frame feature vector $<macro v='frameFeature'/>_{lbp} <macro v='in'/> <mathbb>R</mathbb> ^ {59<macro v='cdot'/><macro v='lbpgridwidth'/><macro v='cdot'/><macro v='lbpgridheight'/>}$.</p>

<figure caption="Histograms of &lt;ac&gt;LBP&lt;/ac&gt; value frequencies are calculated within each area of a $&lt;macro v='lbpgridwidth'/&gt;&lt;macro v='times'/&gt;&lt;macro v='lbpgridheight'/&gt;$ grid. The grid is aligned to the face using an affine transform which reduces the effect of head pose and translation." label="FigureLbpGrid">
<graphic width="0.8">nvcclass/lbp-face-grid-overlay.jpg</graphic>
</figure>

</subsection>
</section>
<section title="Classification for &lt;ac&gt;NVC&lt;/ac&gt;" label="SectionClassificationMethods">

<p>The automatic <ac>NVC</ac> system was tested using both Adaboost and <ac>SVM</ac> classifiers. These classifiers have been shown to be effective in various facial analysis applications. They are both binary classifiers, which are suitable for our constrained problem. The method for comparing the classifier predictions to ground truth is described in Section <ref label='SectionClassificationPerformance'/>. The <ac>NVC</ac> corpus contains video clips of different lengths but temporal variations are not directly modelled by these classifiers. The approach used here is to classify each frame and then fuse the classifier outputs to produce a final label. 
Basic temporal models that encode information from multiple frames are used in Sections <ref label='SectionTemporalFeatures'/> and <ref label='SectionClipFeatureExtraction'/>. The training samples used to create the classifier model corresponding to individual frames, however not every frame necessarily contains relevant information. A training clip is used in its entirety, which can lead to a proportion of irrelevant frames being included in the classification model, resulting in a drop in performance. 
For a clip of length $<macro v='numClipFrames'/>$ frames, the $<macro v='numFeatures'/>$-dimensional frame features $<macro v='frameFeature'/>$ are concatenated into a clip feature matrix $<macro v='clipFeature'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numClipFrames'/> <macro v='times'/> <macro v='numFeatures'/>}$. All clip feature matrices $<macro v='clipFeature'/>$ are concatenated into a global feature vector $<macro v='globalFeature'/>$, which for a corpus of $<macro v='framesInCorpus'/>$ frames: $<macro v='globalFeature'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='framesInCorpus'/> <macro v='times'/> <macro v='numFeatures'/>}$.</p>

<subsection title="Adaboost Classifier" label="SectionAdaboost">

<p>Adaboost is a supervised binary classifier based on a weighted combination of an ensemble of “weak learner” binary inputs <cite ref='Freund1996'/>. The input data can contain significant feature noise, but as long as the features are better than random, they are combined by Adaboost to produce a strong classifier. The algorithm operates by incrementally adding feature components to a bank with a corresponding weight. The algorithm selects feature components in an attempt to reduce the training error while focusing on samples that are hardest to classify. At termination, the selected features and weights specify a strong classifier that may be used to predict unseen examples.</p>

<p>Adaboost is simple to implement, computationally efficient, generally avoids over-training and provides explicit information as to which features are relevant. However, it does not perform as well as other machine learning techniques in some situations. Mislabelled training data can be problematic for some types of classifier, such as Adaboost <cite ref='Natsuki2008'/>.</p>

<p>All the <macro v='featureGeneration'/> techniques described in Section <ref label='SectionFeatureGeneration'/> result in continuous value features. However, Adaboost is limited to binary input data and two class problems. 
For each continuous value feature component, the discretisation is performed by $<macro v='numThresholds'/>$ binary thresholds, designated as $<macro v='thresholdVal'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numThresholds'/> <macro v='times'/> <macro v='numFeatures'/>}$. The placement of thresholds for feature component $j  <macro v='in'/> \{1...<macro v='numFeatures'/><macro v=''/>}$ is determined as follows ($i <macro v='in'/> \{1...<macro v='numThresholds'/><macro v=''/>}$):</p>

eqn\begin{gather}
eqn\thresholdVal_{1,j} = \overline{\globalFeature_j} - \sigma(\globalFeature_j) \\
eqn\thresholdVal_{\numThresholds,j} = \overline{\globalFeature_j} + \sigma(\globalFeature_j) \\
eqn\thresholdVal_{i,j} = \frac{i-1}{\numThresholds-1}(\thresholdVal_{\numThresholds,j} - \thresholdVal_{1,j}) + \thresholdVal_{1,j}
eqn\end{gather}

<p>where $<macro v='globalFeature'/>_j$ is the $j$th row of the global feature matrix $<macro v='globalFeature'/>$ and $<overline><macro v='globalFeature'/>_j</overline>$ is the mean of $<macro v='globalFeature'/>_j$ and $<macro v='sigma'/>(<macro v='globalFeature'/>_j)$ is the variance of the $j$th feature component. A scaling factor of one standard deviation was experimentally determined. The thresholds are computed on all video samples, which arguably violates the separation of training and test data (<ac>SVM</ac>s, presented in the next section, do not have this issue.) However, this effect should be minimal because little person specific information is used. These thresholds are then applied to the feature vector to produce a discretised feature vector $<macro v='discretisedFeatures'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numClipFrames'/> <macro v='times'/> <macro v='numFeatures'/><macro v=''/> <macro v='numThresholds'/>}$, $a <macro v='in'/> {1...<macro v='numClipFrames'/>}$:</p>

eqn\begin{gather}
eqn\discretisedFeatures_{a,\numThresholds (j-1)+i} = \begin{cases}
eqn+1, &amp; \mbox{if } \clipFeature_{a,i} \ge \thresholdVal_{j,i} \\ -1, &amp; \mbox{if } \clipFeature_{a,i} &lt; \thresholdVal_{j,i}
eqn\end{cases}
eqn\end{gather}

<p>These thresholds effectively subdivide the feature space by axis parallel hyperplanes with the middle hyperplane positioned on the mean value.</p>

</subsection>
<subsection title="Support Vector Machines Classifier" label="SectionSupportVectorMachines">

<p>An <ac>SVM</ac> is a supervised learning method originally formulated for binary classification <cite ref='Cortes1995, Vapnik1998'/>, although an extension to regression <cite ref='Drucker1997'/> also exists. <ac>SVM</ac>s use the concept that, although in an original feature space the training samples may not be linearly separable, there exists a non-linear mapping to another space in which a problem is linearly separable. The space is remapped by the use of kernels centred on training samples. An unseen test sample is transformed into this new space and classified based on a simple threshold. The algorithm is difficult to implement efficiently but allows continuous value input variables. This avoids the need to discretise our input features. Unfortunately, the algorithm provides no direct way to examine which features are relevant. This chapter uses the original “C-SVM” formulation of <ac>SVM</ac>s, rather than the later $<macro v='nu'/>$-SVM variant <cite ref='Scholkopf2000'/>. An <ac>SVM</ac> may be trained with various kernels; in this study the <ac>RBF</ac> kernel is used, which is often seen to be effective <cite ref='Shan2009'/>. A regression variant of <ac>SVM</ac>, called $<macro v='nu'/>$-SVR, is used in Chapter <ref label='ChapterNvcRegression'/>.</p>

</subsection>
</section>
<section title="NVC Labels and Use of Clear Examples in Classification" label="SectionClearExamples">

<p>The annotation questionnaire was based on four independently varying <ac>NVC</ac> signals.
The four components of <ac>NVC</ac> rating categories are four independent problems to be solved.
Predictions that distinguish between strong and weak intensity signals, rather than simply positive and negative classification, makes the prediction labels richer and possibly more useful for real applications. However, many machine learning techniques only address classification problems. Also, given the expected difficulty in completely solving the <ac>NVC</ac> recognition problem (see Section <ref label='BackgroundWhyIsNvcDifficult'/>), this chapter addresses a simpler problem by reducing it to a classification task. This is similar to existing studies conducted on emotion recognition that treated the task as a two class <cite ref='Rosenblum1996'/> or multi-class problem <cite ref='Cohen2000'/>. The problem of directly recognizing different <ac>NVC</ac> intensities is addressed in Chapter <ref label='ChapterNvcRegression'/>. A set containing all clips in the corpus is designated as $<macro v='allClipSet'/>$. As discussed in Section <ref label='SectionAnalysisOfMeanRatings'/>, the consensus mean rating of a clip is denoted $<macro v='clipConcensus'/>$ and contains 4 components corresponding to the four <ac>NVC</ac> signals.</p>

<p>In this study, clips that were rated as strongly showing an <ac>NVC</ac> signal were assigned to first positive set and examples that had been rated (by consensus $<macro v='clipConcensus'/>$) as an absence of an <ac>NVC</ac> signal were assigned to the negative set. Only the 25 highest and 25 lowest ratings were considered as clear examples, as this was judged to be enough for training while excluding more difficult ambiguous examples from both training and testing. Because each component of $<macro v='clipConcensus'/>$ can vary independently, the clip sets containing positive and negative examples of <i>thinking</i> are different to the positive and negative sets for <i>agree</i>. The clear examples for each <ac>NVC</ac> category are designated as follows: positive <i>thinking</i> set $<macro v='clearClipSet'/>^{+}_{thinking}$, negative <i>thinking</i> set $<macro v='clearClipSet'/>^{-}_{thinking}$, positive <i>agree</i> set $<macro v='clearClipSet'/>^{+}_{agree}$, negative <i>agree</i> set $<macro v='clearClipSet'/>^{-}_{agree}$, etc. ($<macro v='clearClipSet'/>^{+}_{<macro v='nvcCategory'/>} <macro v='in'/> <macro v='allClipSet,'/> <macro v='clearClipSet'/>^{-}_{<macro v='nvcCategory'/>} <macro v='in'/> <macro v='allClipSet'/>$) The clips are ordered based on the mean annotator rating, $<macro v='nvcCategory'/> <macro v='in'/> <macro v='setCategories'/>$:</p>

eqn\begin{gather}
eqn \overline{\allClipSet}_{\nvcCategory} = \{i \in \{1,...,\numClips\} : \clipConcensus_{\nvcCategory,i} \le \clipConcensus_{\nvcCategory,i+1} \}
eqn\end{gather}

The indices of the 25 most positive and 25 most negative clips are identified:

eqn\begin{gather}
eqn \overline{\allClipSet}^{+}_{\nvcCategory} = (\overline{\allClipSet}_{\nvcCategory,i})^{\numClips}_{i=\numClips-25} \\
eqn \overline{\allClipSet}^{-}_{\nvcCategory} = (\overline{\allClipSet}_{\nvcCategory,i})^{25}_{i=1}
eqn\end{gather}

The final positive and negative sets are then established:

eqn\begin{gather}
eqn \clearClipSet^{+}_{\nvcCategory} = \{\allClipSet_i : i \in \overline{\allClipSet}^{+}_{\nvcCategory}\} \\
eqn \clearClipSet^{-}_{\nvcCategory} = \{\allClipSet_i : i \in \overline{\allClipSet}^{-}_{\nvcCategory}\}
eqn\end{gather}

<p>For a single <ac>NVC</ac> signal category $<macro v='nvcCategory'/>$, the union between positive and negative sets is then determined for each <ac>NVC</ac> signal $<macro v='clearClipSet'/>^{clear}_{<macro v='nvcCategory'/>} = <macro v='clearClipSet'/>^{+}_{<macro v='nvcCategory'/>} <macro v='cup'/> <macro v='clearClipSet'/>^{-}_{<macro v='nvcCategory'/>}$. There were only a few examples of <ac>NVC</ac> disagreement and the three other <ac>NVC</ac> signals had rating scales from neutral to intense expression. For these reasons, examples of disagreement were discarded and <i>agree</i> samples were drawn from neutral and positive samples. The next section describes how these machine learning methods are evaluated and compared.</p>

</section>
<section title="Performance Evaluation Methods for Variable Length Video Clips" label="SectionClassificationPerformance">

<p>Given the relative difficulty in collecting and annotating data, the available data should be used as efficiently as possible. Therefore, cross validation testing is used, which tests an automatic system in multiple folds. Each fold uses a different partitioning of the data into sets of training and test samples.
Eight fold cross validation is used in both person dependent and person independent tests. For person independent testing, this is equivalent to “leave one subject out” testing.</p> 

<p>The sample videos have various lengths and the automatic system needs to process them in a way that enables comparison with the true label.
The difference between the predicted labels and actual labels is then quantified. Perhaps the most widely used binary classification metrics are accuracy, F1 score and <ac>ROC</ac> <ac>AUC</ac>. Apart from being a popular metric, <ac>ROC</ac> analysis is used because the application and acceptable rate of failure are unknown. <ac>ROC</ac> analysis shows the system behaviour under a range of false positive rates. 
The equations for the commonly used metrics are (adapted from <cite ref='Sokolova2006'/>):</p>

eqn\begin{gather}
eqn\label{EquationFirstBinaryMetric}
eqnpositive = true\_positive + false\_negative \\
eqnnegative = true\_negative + false\_positive \\
eqnaccuracy = \frac{true\_positive + true\_negative}{positive + negative}\\
eqnprecision = \frac{true\_positive}{true\_positive + false\_positive}\\
eqnrecall = \frac{true\_positive}{positive}\\
eqnf1\_score = \frac{2 \cdot precision \cdot recall}{precision + recall}
eqn\end{gather}

<p>Computing the <ac>AUC</ac> of <ac>ROC</ac> requires a sweep of a decision threshold to determine the false positive ($fpr$) and true positive rates ($tpr$). This is often intuitively understood as the area under a plot of $tpr$ vs. $fpr$, but can also be expressed mathematically as:</p>

eqn\begin{gather}
eqnfpr=\frac{false\_positive(threshold)}{negative} \\
eqntpr=\frac{true\_positive(threshold)}{positive} \\
eqn\label{EquationLastBinaryMetric}
eqnarea\_under\_roc=\int_0^1 trp(fpr)\,\mathrm{d}fpr
eqn\end{gather}

<p>Given a two class problem, there are a few different approaches to process a variable length clip to enable comparison with the true label:</p>

<ul>
<li>For each frame in a test clip, the classifier makes a binary prediction. The proportion of positive predictions is taken as the overall positive confidence score. This method is referred to as “clip level” testing. This classification of individual video clips is distinct from event recognition, which is the detection of limited duration events in a longer video <cite ref='Jiang2012'/>.</li>
<li>For each frame, calculate the confidence that the frame is positive. The predictions from multiple frames forms a set of predictions. This set is converted to multiple sets of binary predictions using a  moving threshold, as done with a standard <ac>ROC</ac> analysis. Each thresholded binary prediction is then compared to the video clip label. This side steps the need for fusion and is referred to as “frame level” testing.</li>
<li>Combine the frames to form an overall clip feature vector of fixed length. This concept is explored in Section <ref label='SectionDigestVector'/>.</li>
<li>Use a machine learning method that is dedicated to sequence classification or <ac>MIL</ac> classification. This is discussed further in Section <ref label='SectionHmm'/>.</li>
</ul>

<p>The first two approaches are used to evaluate performance. They were selected because they both utilise confidence ratings which may be evaluated by an <ac>ROC</ac> curve.</p>

</section>
<section title="Results and Discussion" label="SectionNvcClassificationResults">

<p>The <macro v='featureGeneration'/> approaches described above were compared for the four <ac>NVC</ac> categories. The comparison also includes two machine learning techniques (Adaboost and <ac>SVM</ac>) and two ways of measuring the performance (frame level and clip level testing). Comprehensive testing was conducted and full results are reported in Appendix <ref label='ChapterAdditionalClassificationResults'/>. This section presents the summarised performance results. 
Various parameters were tuned through experimental validation: five thresholds were used to discretise features for Adaboost ($<macro v='numThresholds'/> = 5$) and an <ac>SVM</ac> cost parameter $C=1.0$ was used. LBP grid size were $<macro v='lbpgridwidth'/>=10, <macro v='lbpgridheight'/>=10$.</p>

<table short="&lt;ac&gt;AUC&lt;/ac&gt; Performance of various features and classifiers." caption="Performance of various features and classifiers. Clip level testing, average score of categories shown. &lt;ac&gt;SVM&lt;/ac&gt; with Algorithmic Geometric features produce the highest performance. The error limits are based on one standard deviation of the average cross validation fold performance. The data is shown in graphical form in Figures &lt;ref label='CompareGraphMultiPerson'/&gt; and &lt;ref label='PersonIndependentCompareGraph'/&gt;" label="TableCompareFeaturesAndClassifiers">
<tr><td>Test </td><td> Multi-person </td><td></td><td> Person independent </td><td></td></tr>
<tr><td></td><td> SVM </td><td> Adaboost </td><td> SVM </td><td> Adaboost </td></tr>
<tr><td>affine</td><td> 0.52 $<macro v='pm'/>$ 0.05 </td><td> 0.56 $<macro v='pm'/>$ 0.04 </td><td> 0.53 $<macro v='pm'/>$ 0.05 </td><td> 0.51 $<macro v='pm'/>$ 0.06</td></tr>
<tr><td>deform-cubica</td><td> 0.50 $<macro v='pm'/>$ 0.00 </td><td> 0.55 $<macro v='pm'/>$ 0.06 </td><td> 0.50 $<macro v='pm'/>$ 0.00 </td><td> 0.51 $<macro v='pm'/>$ 0.07</td></tr>
<tr><td>deform-fastica</td><td> 0.50 $<macro v='pm'/>$ 0.00 </td><td> 0.55 $<macro v='pm'/>$ 0.06 </td><td> 0.50 $<macro v='pm'/>$ 0.00 </td><td> 0.51 $<macro v='pm'/>$ 0.07</td></tr>
<tr><td>deform-pca</td><td> 0.54 $<macro v='pm'/>$ 0.04 </td><td> 0.68 $<macro v='pm'/>$ 0.05 </td><td> 0.50 $<macro v='pm'/>$ 0.00 </td><td> 0.62 $<macro v='pm'/>$ 0.07</td></tr>
<tr><td>geometric-h</td><td> 0.73 $<macro v='pm'/>$ 0.04 </td><td> 0.68 $<macro v='pm'/>$ 0.06 </td><td> 0.63 $<macro v='pm'/>$ 0.05 </td><td> 0.60 $<macro v='pm'/>$ 0.08</td></tr>
<tr highlight="yes"><td>geometric-a</td><td> 0.75 $<macro v='pm'/>$ 0.04 </td><td> 0.72 $<macro v='pm'/>$ 0.04 </td><td> 0.70 $<macro v='pm'/>$ 0.04 </td><td> 0.68 $<macro v='pm'/>$ 0.05</td></tr>
<tr><td>lbp</td><td> 0.58 $<macro v='pm'/>$ 0.05 </td><td> 0.62 $<macro v='pm'/>$ 0.05 </td><td> 0.52 $<macro v='pm'/>$ 0.07 </td><td> 0.48 $<macro v='pm'/>$ 0.10</td></tr>
<tr><td>lma</td><td> 0.53 $<macro v='pm'/>$ 0.06 </td><td> 0.56 $<macro v='pm'/>$ 0.04 </td><td> 0.49 $<macro v='pm'/>$ 0.02 </td><td> 0.50 $<macro v='pm'/>$ 0.08</td></tr>
</table>

<p>Table <ref label='TableCompareFeaturesAndClassifiers'/> shows the results of each of the various <macro v='featureGeneration'/> approaches, as well as comparing multi-person and person independent testing. For brevity, the performance of each of the four <ac>NVC</ac> categories (<i>agree</i>, <i>thinking</i>, <i>understand</i> and <i>question</i>) are averaged to provide a single performance score for each clip. To analyse statistical significance in performance differences, Welch's t-test <cite ref='Welch1947'/> is employed because the cross fold variances of performance for different methods are unequal. However, this ignores the effect of personal differences in expressivity and style (see Section <ref label='BackgroundWhatFactorsInfluenceNvc'/>), which is likely to cause each cross validation fold to have significant differences in performance. For this reason, the sample variance for this analysis is likely to be inflated and the t-test will be pone to underestimate the true significance. Also, k-fold cross validation is not an ideal approach to demonstrate statistical significance <cite ref='Dietterich1998'/>. The statistical significance analysis in this chapter should be considered in this context. Future work may address this by using additional subjects and a cross validation approach to be more statistically appropriate (see <cite ref='Grandvalet2006'/>).</p>

<p>Considering person independent SVM classification, <i>geometric-a</i> features perform more effectively than <i>affine</i> features (significance $p=0.07$) and <i>lbp</i> features ($p=0.07$). <i>Geometric-a</i> features may be more effective than <i>geometric-h</i> features, although this effect does not reach statistical significance ($p=0.26$). For person independent <i>geometric-a</i> features, the performance of SVM is not significantly better than Adaboost ($p=0.43$). For <i>geometric-a</i> features with an SVM classifier, person independent classification is not significantly harder than multi-person testing ($p=0.31$).</p>

<p>Some approaches operate only slightly above chance level (<ac>AUC</ac> of $0.50$) such as head pose features <i>affine</i> and <i>lma</i>. This suggests that head pose information alone cannot reliably classify <ac>NVC</ac> signals, although head pose may play a secondary role in <ac>NVC</ac> expression.</p>

<p>Features based on projecting the face shape information into a <ac>ICA</ac> space did not result in good performance (<i>deform-cubica</i> and <i>deform-fastica</i>). 
PCA based face deformations were more effective than <ac>ICA</ac>. For the <ac>SVM</ac> classifier, multi-person testing of <i>deform-pca</i> resulted in an intermediate performance of $0.68$. When this method was applied to person independent testing, the performance drops to $0.62$. This indicates that <i>deform-pca</i> <ac>SVM</ac> creates a model that can predict <ac>NVC</ac> labels on unseen video clips if the test subject is present in the training data. 
This pattern of lower person independent performance is repeated for the other <macro v='featureGeneration'/> techniques, when the multi-person and person independent testing performances are compared (see Table <ref label='TableCompareFeaturesAndClassifiers'/>).</p>

<p>The only appearance features used, <i>lbp</i>, did not perform as well as other approaches in multi-person testing ($0.62$ with Adaboost in Table <ref label='TableCompareFeaturesAndClassifiers'/>) despite the use of head pose normalisation. 
This is surprising because, as discussed in Section <ref label='BackgroundEncodeFacialInfo'/>, facial texture is often used for the encoding of facial information. The failure of <i>lbp</i> features for <ac>NVC</ac> signals may be due to one or more of:</p>

<ul>
<li>facial texture does not contain information about <ac>NVC</ac>, which is unlikely, </li>
<li>person specific face shape and appearance differences reduce the generalisation of classifier models. This should not affect algorithmic geometric features because of the normalisation but features such as <ac>LBP</ac> will encode person specific information that is not relevant to behaviour recognition,</li>
<li>an affine transform is used for head pose normalisation. This is a simplistic model and perhaps a more sophisticated model might be effective in removing the effect of head pose, or</li>
<li><ac>LBP</ac>s or <i>lbp</i> may be inappropriate for <ac>NVC</ac> recognition, but a different texture descriptor may be more effective.</li>
</ul>

<p>Unfortunately, it is difficult to confirm which of these possibilities is true without further experiments.</p>

<p>For multi-person <ac>SVM</ac> testing features, geometric features (<i>geometric-h</i> and <i>geometric-a</i>) have the highest performance values of $0.73$ and $0.75$ respectively (see Table <ref label='TableCompareFeaturesAndClassifiers'/>). However, <i>geometric-h</i> features drop to a performance of $0.63$ in the person independent case. 
In the case of <i>geometric-a</i>, the drop is less ($0.05$) to a performance of $0.70$, which indicates that these features are less reliant on person specific patterns. 
Zero centring and scaling features to remove person specific features might benefit facial texture features as well, but this was not performed.</p>

<figure short="Comparison of &lt;b&gt;multi-person&lt;/b&gt; performance for different features." caption="Comparison of &lt;b&gt;multi-person&lt;/b&gt; performance for different features. Testing is at clip level, with the average score of all four &lt;ac&gt;NVC&lt;/ac&gt; categories. A performance of 0.5 is equivalent to classification by chance. SVM with geometric algorithmic features provides the best performance." label="CompareGraphMultiPerson">
<graphic width="0.6">nvcclass/compare-multi-person.pdf</graphic>
</figure>

<figure short="Comparison of &lt;b&gt;person independent&lt;/b&gt; performance for different features." caption="Comparison of &lt;b&gt;person independent&lt;/b&gt; performance for different features. Testing is at clip level, with the average score of all four &lt;ac&gt;NVC&lt;/ac&gt; categories. A performance of 0.5 is equivalent to classification by chance. SVM with geometric algorithmic features provides the best performance." label="PersonIndependentCompareGraph">
<graphic width="0.6">nvcclass/compare-person-indep.pdf</graphic>
</figure>

<p>For the higher performing geometric features <i>geometric-h</i> and <i>geometric-a</i>, <ac>SVM</ac> performance exceeds the performance for Adaboost. This may be due to information loss in the feature discretisation process, or <ac>SVM</ac> was better suited to this task.</p>

<p>The performance for each <ac>NVC</ac> signal is of interest, because some <ac>NVC</ac>s may be easier or harder to recognise automatically. 
To limit the quantity of results to a manageable amount, only the top two approaches (SVM with <i>geometric-a</i> and <i>geometric-h</i>) are presented in the following discussion. Also, person independent testing is used exclusively, since this is a more challenging and general problem.</p>

<table short="&lt;ac&gt;AUC&lt;/ac&gt; Performance for algorithmic geometric features &lt;b&gt;&lt;i&gt;geometric-a&lt;/i&gt; using SVM&lt;/b&gt; (person independent testing)." caption="Performance for algorithmic geometric features &lt;b&gt;&lt;i&gt;geometric-a&lt;/i&gt; using SVM&lt;/b&gt; (person independent testing). Confidence intervals of two standard deviations are shown. Classification at the clip level provides better performance then frame level testing (but further tests are required to establish statistical significance). &lt;i&gt;question&lt;/i&gt; is the hardest NVC category to classify." label="TableAlgorithmicFeatures">
<tr><td>Testing </td><td> Agree </td><td> Question </td><td> Thinking </td><td> Understand</td></tr>
<tr><td>Clip level </td><td> 0.67$<macro v='pm'/>$0.04 </td><td> 0.64$<macro v='pm'/>$0.10 </td><td> 0.77$<macro v='pm'/>$0.08 </td><td> 0.71$<macro v='pm'/>$0.10</td></tr> <!--XI-->
<tr><td>Frame level </td><td> 0.66$<macro v='pm'/>$0.06 </td><td> 0.54$<macro v='pm'/>$0.02 </td><td> 0.70$<macro v='pm'/>$0.06 </td><td> 0.70$<macro v='pm'/>$0.04</td></tr> <!--X-->
</table>

<p>Table <ref label='TableAlgorithmicFeatures'/> shows the <i>geometric-a</i> SVM performance for the 4 <ac>NVC</ac> categories for person independent testing. 
<i>Thinking</i> appears to be the easiest <ac>NVC</ac> signal to recognise, while <i>question</i> is the hardest. 
Low <i>question</i> performance is probably due to the <ac>NVC</ac> being primarily expressed by voice intonation <cite ref='Verderber2007'/> and sentence context, rather than any visual cue. Also, <i>question</i> category contains fewer positive examples than the other <ac>NVC</ac> signals in this study (Figure <ref label='RatingScoresFigure'/>). Thinking has a characteristic visual appearance which is relatively easy to identify, as discussed in Section <ref label='SectionVisualisingGaze'/>.
As previously observed, clip level classification reports a higher performance than frame level classification.
However, it is difficult to establish the statistical significance of this result, due to the effect of personal differences increasing the variance of observed performance in the cross validation process. If this effect is ignored and <i>thinking</i> <ac>NVC</ac> is considered, clip level performance (0.77$<macro v='pm'/>$0.04) exceeds the performance of frame level classification (0.70$<macro v='pm'/>$0.03) with a significance of only $p=0.23$. Further experiments are required to establish if this result is statistically significant.</p>

<table short="&lt;ac&gt;AUC&lt;/ac&gt; Performance for heuristic geometric &lt;b&gt;&lt;i&gt;geometric-h&lt;/i&gt; features using SVM&lt;/b&gt; classification (person independent testing)." caption="Performance for heuristic geometric &lt;b&gt;&lt;i&gt;geometric-h&lt;/i&gt; features using SVM&lt;/b&gt; classification (person independent testing). Confidence intervals of two standard deviations are shown Clip level classification performance exceeds frame level performance. Although performance is generally lower than the use of algorithmic geometric features (Table &lt;ref label='TableAlgorithmicFeatures'/&gt;), the &lt;i&gt;agree&lt;/i&gt; NVC performance is significantly better for heuristic geometric features." label="TableHeuristicFeatures">
<tr><td>Testing </td><td> Agree </td><td> Question </td><td> Thinking</td><td> Understand</td></tr>
<tr><td>Clip level </td><td> 0.73$<macro v='pm'/>$0.08 </td><td> 0.54$<macro v='pm'/>$0.16 </td><td> 0.58$<macro v='pm'/>$0.00 </td><td> 0.68$<macro v='pm'/>$0.16</td></tr> <!--XI-->
<tr><td>Frame level </td><td> 0.59$<macro v='pm'/>$0.04 </td><td> 0.51$<macro v='pm'/>$0.04 </td><td> 0.52$<macro v='pm'/>$0.04 </td><td> 0.56$<macro v='pm'/>$0.04</td></tr> <!--X-->
</table>

<p>Moving from <i>geometric-a</i> to <i>geometric-h</i> features, which are shown in Table <ref label='TableHeuristicFeatures'/>, the classification performance is significantly lower overall than in Table <ref label='TableAlgorithmicFeatures'/>. However, the performance for <i>thinking</i> in the case of <i>geometric-h</i> exceeds features generated by <i>geometric-a</i>. This shows that although <i>geometric-a</i> is generally a good method for encoding different <ac>NVC</ac> signals, it is not necessarily optimal for all types of <ac>NVC</ac>. As above, statistical significance is low due to the effect of personal differences and further tests are required to establish significance.</p>

</section>
<section title="&lt;macro v='temporalFeatPluralCap'/&gt; using Quadratic Curve Fitting" label="SectionTemporalFeatures">

<figure short="Illustration of &lt;macro v='temporalFeatPlural'/&gt; for a simple two component frame feature with a single temporal window size." caption="Illustration of &lt;macro v='temporalFeatPlural'/&gt; for a simple two component frame feature with a single temporal window size. A quadratic curve is fitted to samples in a sliding window. The parameters that describe the curve form part of the temporal vector." title="FigureTemporalFeatures">
<graphic width="0.7">nvcclass/temporalFeatures.pdf</graphic>
</figure>

<p>Humans use the face shape and appearance variation in time for recognition of behaviour. 
Temporal variation of features should be investigated to attempt to achieve better automatic performance of emotion and <ac>NVC</ac>.
This information is encoded by <macro v='temporalFeatPlural,'/> which are defined here as the result of combining data from multiple sensor observations taken at a range of times. The temporal order of observations may be retained in the <macro v='featureGeneration'/> process, or it may be discarded.
To create <macro v='temporalFeatPlural,'/> each component of a clip feature (e.g. $<macro v='clipFeature'/>_{geometric-h}$) is considered independently and in a sliding window (see Figure <ref label='FigureTemporalFeatures'/>). A quadratic curve is fitted to the feature values in the sliding window $<macro v='temporalWindow'/>$ of $<macro v='temporalWindowSize'/>$ frames using least squares fitting $<macro v='temporalWindow'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='temporalWindowSize'/> <macro v='times'/> <macro v='numFeatures'/> <macro v='times'/> <macro v='numClipFrames'/>}$. The parameters of the curve $<macro v='temporalWindowFeature'/>$ are then used as the <macro v='temporalFeatSingle,'/> which describes how a frame based feature varies over time in a temporal window $<macro v='temporalWindowFeature'/> <macro v='in'/> <mathbb>R</mathbb>^{<macro v='numClipFrames'/> <macro v='times'/> 3 <macro v='numFeatures'/>}$. This approach is related to Savitzky--Golay filtering <cite ref='Savitzky1964'/> and was previously used by Petridis and Pantic <cite ref='Petridis2008'/> to create <macro v='temporalFeatPlural'/> for laughter detection. 
For the $i$th feature component $i <macro v='in'/> \{1...<macro v='numFeatures'/><macro v=''/>}$, at temporal window frame position $j$, $<macro v='timeOffset'/> <macro v='in'/> \{1...<macro v='temporalWindowSize'/><macro v=''/>}, j <macro v='in'/> \{1...<macro v='numClipFrames'/><macro v=''/>}, <b>a</b> = \{<b>a</b>_{1}, <b>a</b>_{2}, <b>a</b>_{3}\}$:</p>

eqn\begin{gather}
eqn\temporalWindow_{\timeOffset,i,j} = \clipFeature_{\timeOffset+j,i} \\
eqn\polyFunc(\textbf{a},\timeOffset) = \textbf{a}_1 \timeOffset^2 + \textbf{a}_2 \timeOffset + \textbf{a}_3 \\
eqn\{\temporalWindowFeature_{j,3i-2},\temporalWindowFeature_{j,3i-1},\temporalWindowFeature_{j,3i}\} = \argmin_{\textbf{a}} {\displaystyle\sum\limits_{\timeOffset=1}^{\temporalWindowSize} | \temporalWindow_{\timeOffset,i,j} - \polyFunc(\textbf{a},\timeOffset) |}
eqn\end{gather}

<p>Because the optimal size of the temporal window is unknown, multiple window sizes are used to form the <macro v='temporalFeatPlural.'/> The number of temporal windows is denoted as $<macro v='numTemporalWindows'/>$. The combined <macro v='temporalFeatSingle'/> $<macro v='temporalFeature'/>$ is the concatenation of the various temporal windows, and the original frame feature $<macro v='frameFeature'/>$ on frame $j$:</p>

eqn\begin{gather}
eqn\temporalFeature_{j} = \{\frameFeature_1...\frameFeature_{\numFeatures},\temporalWindowFeature^1_{j,1}...\temporalWindowFeature^1_{j,3 \numFeatures},...,\temporalWindowFeature^\numTemporalWindows_{j,1}...\temporalWindowFeature^\numTemporalWindows_{j, 3 \numFeatures}\} \\
eqn\temporalFeature \in \mathbb{R}^{\numClipFrames \times (3 \numTemporalWindows + 1) \numFeatures}
eqn\end{gather}

<p>The next section discusses their performance in <ac>NVC</ac> classification.</p>

<subsection title="Results and Discussion">

<p>The temporal window lengths used were 80ms, 160ms, 320ms and 640ms ($<macro v='numTemporalWindows'/> = 4$). As before, five thresholds ($<macro v='numThresholds'/> = 5$) were used for Adaboost classification. The SVM cost parameter $C$ of 1.0 was found to be effective.</p>

<table short="Comparison of &lt;ac&gt;AUC&lt;/ac&gt; performance of &lt;macro v='temporalFeatPlural'/&gt; generated based on $&lt;macro v='temporalFeature'/&gt;_{geometric-h}$." caption="Comparison of &lt;ac&gt;AUC&lt;/ac&gt; performance of &lt;macro v='temporalFeatPlural'/&gt; generated based on $&lt;macro v='temporalFeature'/&gt;_{geometric-h}$. SVM Classification was assessed by person independent testing. Confidence intervals of two standard deviations are shown" label="TableHeuristicFeaturesTemporal">
<tr><td><macro v='temporalFeatPluralCap'/> </td><td> Testing </td><td> Agree </td><td> Question </td><td> Think </td><td> Understand</td></tr>
<tr><td>No </td><td> Clip level </td><td> 0.73$<macro v='pm'/>$0.08 </td><td> 0.54$<macro v='pm'/>$0.16 </td><td> 0.58$<macro v='pm'/>$0.00 </td><td> 0.68$<macro v='pm'/>$0.16</td></tr> <!--XI-->
<tr highlight="yes"><td>Yes </td><td> Clip level </td><td> 0.74$<macro v='pm'/>$0.06 </td><td> 0.57$<macro v='pm'/>$0.10 </td><td> 0.60$<macro v='pm'/>$0.04 </td><td> 0.69$<macro v='pm'/>$0.12</td></tr> <!--XI-->
<tr><td>No </td><td> Frame level </td><td> 0.59$<macro v='pm'/>$0.04 </td><td> 0.51$<macro v='pm'/>$0.04 </td><td> 0.52$<macro v='pm'/>$0.04 </td><td> 0.56$<macro v='pm'/>$0.04</td></tr> <!--X-->
<tr><td>Yes </td><td> Frame level </td><td> 0.60$<macro v='pm'/>$0.04 </td><td> 0.51$<macro v='pm'/>$0.04 </td><td> 0.55$<macro v='pm'/>$0.04 </td><td> 0.58$<macro v='pm'/>$0.04</td></tr> <!--X-->
</table>

<p>The performance of <macro v='temporalFeatPlural'/> is shown in Table <ref label='TableHeuristicFeaturesTemporal'/>. Heuristic features $<macro v='temporalFeature'/>_{geometric-h}$ were used instead of $<macro v='temporalFeature'/>_{geometric-a}$ features because its feature matrix is extremely large and exceeds available computer memory resources. The usage of <macro v='temporalFeatPlural'/> only results in a slight or negligible improvement in performance in both clip and frame level testing, however further tests are required to establish statistical significance. 
The performance improvement may be due to input smoothing rather than the linear or quadratic terms in the polynomial being useful. This possibility is supported by feature weights assigned in an Adaboost strong classifier; quadratic and linear terms are generally not selected. In the work by Petridis and Pantic <cite ref='Petridis2008'/>, tests showed performance was not significantly affected by varying the temporal window size (Table 2 in their paper). However, humans require temporal information to identify complex emotion, so it is unlikely that temporal information has no role in <ac>NVC</ac>. Other approaches to <macro v='temporalFeatPlural'/> and classification are investigated in Sections <ref label='SectionHmm'/> and <ref label='SectionClipFeatureExtraction'/>.</p>

</subsection>
</section>
<section title="Visualising Gaze Features during Thinking" label="SectionVisualisingGaze">

<figure short="Frames from the top 4 annotator rated examples of positive &lt;i&gt;thinking&lt;/i&gt;." caption="Frames from the top 4 annotator rated examples of positive &lt;i&gt;thinking&lt;/i&gt;. Averted gaze is strongly expressed in positive examples of &lt;i&gt;thinking&lt;/i&gt;. The specific frames from the clip were manually selected." label="FigurePosThinkingGbr">
<graphic width="0.49">nvcclass/pos_thinking_clip_0ikEnNwEiH.jpg</graphic>
<graphic width="0.49">nvcclass/pos_thinking_clip_1HrHJGReu2.jpg</graphic><br/>
<graphic width="0.49">nvcclass/pos_thinking_clip_G3N4eNTLUH.jpg</graphic>
<graphic width="0.49">nvcclass/pos_thinking_clip_t8jTJw1Zrs.jpg</graphic>
</figure>

<figure short="Frames from the top 4 annotator rated examples of negative &lt;i&gt;thinking&lt;/i&gt;, i.e. &lt;i&gt;thinking&lt;/i&gt; is not present." caption="Frames from the top 4 annotator rated examples of negative &lt;i&gt;thinking&lt;/i&gt;, i.e. &lt;i&gt;thinking&lt;/i&gt; is not present. Eye contact is maintained in negative examples of &lt;i&gt;thinking&lt;/i&gt;. The specific frames from the clip were manually selected." label="FigureNegThinkingGbr">
<graphic width="0.49">nvcclass/neg_thinking_clip_9B4pDQJIUC.jpg</graphic>
<graphic width="0.49">nvcclass/neg_thinking_clip_BShb9DBvU0.jpg</graphic><br/>
<graphic width="0.49">nvcclass/neg_thinking_clip_CTIOfHcxSt.jpg</graphic>
<graphic width="0.49">nvcclass/neg_thinking_clip_DGUb6od8BB.jpg</graphic>
</figure>

<p>This section will consider a simplified problem that is intended to provide insight into how <ac>NVC</ac> signals are manifested in feature space. This can inform the decision on how to approach the problem. The <ac>NVC</ac> for <i>thinking</i> is used, because clear positive and negative examples of this signal have a distinctive gaze pattern. This has previously been observed in various studies, such as McCarthy <macro v='etal'/> <cite ref='McCarthy2006'/>, which found that eye contact was broken when a person is thinking about how to answer a question (see Figures <ref label='FigurePosThinkingGbr'/> and <ref label='FigureNegThinkingGbr'/>).</p>

<p>Two features from heuristic geometric features, introduced in Section <ref label='SectionGenerateHeuristic'/>, are used to encode eye movements. Using the full <i>geometric-h</i> feature vector would be difficult to visualise as a 2{D} plot, so the 2 features that are relevant are manually selected. The 9th and 12th feature of <i>geometric-h</i> corresponds to “Mean eye horizontal” and “Mean eye vertical” positions respectively (see Table <ref label='GeometryFeaturesTable'/>), which will be referred to as the “gaze subset”. These simple features can be used to visualised positive and negative samples.</p>

<figure short="Eye trajectories in the top 1% positive and top 1% negative examples of &lt;i&gt;thinking&lt;/i&gt;." caption="Eye trajectories in the top 1% positive and top 1% negative examples of &lt;i&gt;thinking&lt;/i&gt;. The left plot shows the negative examples. The right plot shows the positive examples. The trajectory shape in the plot correspond to observed eye motion i.e. the top of the plot corresponds to looking upwards. Differences in line shading correspond to different video samples." label="FigureThinkingTrajectoryPosNeg">
<graphic width="0.49">nvcclass/traj0.pdf</graphic>
<graphic width="0.49">nvcclass/traj99.pdf</graphic>
</figure>

<p>Each annotated example is a video clip containing multiple frames. The gaze subset of <i>geometric-h</i> encode each frame as a 2 component vector. This trajectory is shown in Figure <ref label='FigureThinkingTrajectoryPosNeg'/> as a 2D plot. As can be seen, gaze in negative examples is relatively steady and is generally near the origin, which corresponds to frontal gaze. Any motion away from the origin is due to eye motion or tracker noise. Gaze in positive examples of thinking contain significantly more variation and excursions from the origin to the upper right in the plot. This corresponds to the characteristic thinking behaviour seen in Figure <ref label='FigurePosThinkingGbr'/>. This makes positive and negative examples quite distinct in feature space. These patterns in eye movement are likely to be used for automatic <i>thinking</i> recognition (this is verified in Section <ref label='SectionVisualiseFeatureSelection'/>).</p>

<figure short="Eye trajectories in the middle 1% examples of &lt;i&gt;thinking&lt;/i&gt;." caption="Eye trajectories in the middle 1% examples of &lt;i&gt;thinking&lt;/i&gt;. The trajectory shape in the plot correspond to observed eye motion i.e. the top of the plot corresponds to looking upwards. Differences in line shading correspond to different video samples." label="FigureThinkingTrajectoryIntermediate">
<graphic width="0.49">nvcclass/traj50.pdf</graphic>
</figure>

<p>While positive and negative examples are easy to distinguish, intermediate strength examples of <i>thinking</i> may prove challenging, if the gaze behaviour is not distinct in gaze feature space. The trajectories of the middle 1% intensity of <i>thinking</i> is shown in Figure <ref label='FigureThinkingTrajectoryIntermediate'/>. As can be seen, the trajectories are not significantly different from negative samples shown in the left plot of Figure <ref label='FigureThinkingTrajectoryPosNeg'/>. This lack of difference may make differentiating between intermediate and negative examples problematic.</p>

<figure short="The mean magnitude of the gaze features for each clip $&lt;macro v='clipFeatureDigestVal'/&gt;$, plotted against the annotator rating of &lt;i&gt;thinking&lt;/i&gt;." caption="The mean magnitude of the gaze features for each clip $&lt;macro v='clipFeatureDigestVal'/&gt;$, plotted against the annotator rating of &lt;i&gt;thinking&lt;/i&gt;. There is a weak linear trend between increasing feature magnitude and the intensity of &lt;i&gt;thinking&lt;/i&gt;.">
<graphic width="0.7">nvcclass/ThinkingGazeMean.pdf</graphic>
</figure>

<p>The feature can be further simplified by computing the average magnitude of eye deviation from frontal gaze. This also enables representation of a clip by a single number $<macro v='clipFeatureDigestVal'/> <macro v='in'/> <mathbb>R</mathbb>$:</p>

eqn\begin{gather}
eqn\clipFeatureDigestVal = 
eqn\frac{\displaystyle\sum\limits_{j=1}^{\numClipFrames} \sqrt{{\clipFeature_{geometric-h,j,9}}^2 + {\clipFeature_{geometric-h,j,12}}^2}}
eqn{\numClipFrames}
eqn\end{gather}

<p>Figures <ref label='FigureThinkingTrajectoryPosNeg'/> and <ref label='FigureThinkingTrajectoryIntermediate'/> only show the trajectories for a small subset of samples. With the mean clip feature $<macro v='clipFeatureDigestVal'/>$, the feature can be plotted against the annotator rating for all samples in the corpus (Figure <ref label='FigureThinkingMeanScatter'/>). As can be seen, there is only a weak linear association between this gaze subset feature and the annotators score. The correlation of the feature with the annotation is $0.21$. This illustrates the difficulty in <ac>NVC</ac> recognition: there is little consistency in human behaviour and while particular facial actions may have statistical connections with <ac>NVC</ac>, they are not definitive. 
Section <ref label='SectionDigestVector'/>  returns to the concept of summarising an entire clip by a single vector. However, it is important to consider this work in the context of the extreme difficulty of the problem.</p>

</section>
<section title="Discussion of Akakın and Sankur, 2011" label="SectionHmm">

<p>An early version of the work in this chapter was published in 2009 <cite ref='SheermanChase2009'/>. A later paper by Akakın and Sankur <cite ref='Akakin2011'/> used the TwoTalk corpus, as well as the BUHMAP database <cite ref='Aran2007'/> to compare approaches to automatic recognition. 
Because of the high relevance of their work to this thesis, this section outlines their approach, and discusses their conclusions in light of more recent work.</p>

<p>Their tracking is based on a detection-track-regularise framework with multiple tracking models to account for head pose changes. They used 1208 training frames, which has a higher manual training requirement than <ac>LP</ac> tracking. Their approach is likely to have better recovery after occlusion and less manual intervention when in operation. The tracking is then used to  generate features: landmark coordinate features, heuristic geometric features, and texture features generated from localised patches. These broad types of features are the same as used in Section <ref label='SectionFeatureGeneration'/>.</p>

<p>They use two broad types of machine learning: feature-sequence classifiers (<ac>HMM</ac>, <ac>HCRF</ac>) and feature subspace learning (<ac>ICA</ac> or <ac>NMF</ac>, classified by <ac>MNN</ac>). A key difference between these methods is feature-sequence classifiers consider the frame order as significant, while feature subspace learning does not. The use of <ac>MNN</ac> is interesting because it allows direct comparison of an entire trajectory with another trajectory. 
The authors provide a justification for using feature-sequence methods by claiming that “even though head and facial gestures may differ in total duration, each follows a fixed pattern of temporal order”. While specific gestures generally have a set pattern, it is possible that a particular <ac>NVC</ac> signal may be expressed by more than one type of gesture.</p>

<table short="&lt;ac&gt;AUC&lt;/ac&gt; performance on the TwoTalk corpus, expressed as percentages." caption="&lt;ac&gt;AUC&lt;/ac&gt; performance on the TwoTalk corpus, expressed as percentages. The first four rows are from Table 11 in Akakın and Sankur, 2011 &lt;cite ref='Akakin2011'/&gt; and are quoted verbatim. Testing is multi-person. Results from &lt;i&gt;geometric-a&lt;/i&gt; with an SVM classifier have been appended for comparison (multi-person, clip level testing) (see Table &lt;ref label='TableCompareFeaturesAndClassifiers'/&gt; and &lt;ref label='SvmClipMultipersonTable'/&gt;)." label="TableCompareToAkakin">
<tr><td>Method </td><td> Agree </td><td> Question </td><td> Thinking </td><td> Understand </td><td> Average</td></tr>
<tr><td>MNN with ICA (P) </td><td> 84.6 </td><td> 67.6 </td><td> 83.5 </td><td> 74.3 </td><td> 77.5</td></tr>
<tr><td>MNN with NMF (P) </td><td> 75.8 </td><td> 60   </td><td> 76.1 </td><td> 77.8 </td><td> 72.4</td></tr>
<tr><td>HCRF (17,G)      </td><td> 78.7 </td><td> 75   </td><td> 73.5 </td><td> 82.5 </td><td> 77.4</td></tr>
<tr><td>Classifier Fusion </td><td> 85.9 </td><td> 78.2 </td><td> 83.8 </td><td> 83.6 </td><td> 82.9</td></tr>
<tr><td>Fused Features, Adaboost </td><td> 70 </td><td> 73 </td><td> 81 </td><td> 80 </td><td> 76</td></tr>
<tr><td><i>geometric-a</i>, SVM </td><td> 70 </td><td> 70 </td><td> 83 </td><td> 75 </td><td> 75</td></tr>
</table>

<p>The results from Akakın and Sankur are reproduced in Table <ref label='TableCompareToAkakin'/>. All the results presented in the comparison were based on evaluation with the TwoTalk corpus.
This table refers to a hybrid approach which is an early version of the approach described in this chapter (see <cite ref='SheermanChase2009'/> for details). This hybrid approach is a concatenation of the features $<macro v='frameFeature'/>_{pca}$, $<macro v='frameFeature'/>_{geometric-h}$, $<macro v='frameFeature'/>_{lma}$ and $<macro v='frameFeature'/>_{affine}$ with polynomial temporal fitting applied (see Section <ref label='SectionTemporalFeatures'/>) with Adaboost. The final row in the table corresponds to the method described in this chapter ($<macro v='frameFeature'/>_{geometric-a}$ and an <ac>SVM</ac> classifier). As can be seen, the non-hybrid approaches methods have similar levels of performance. The use of a single type of sequential classifiers (MNN or HCRF) only results in 2 to 3% improvement over the <i>geometric-a</i> with the <ac>SVM</ac> approach.</p>

<p>Comparing the non-fused approaches, the best approach for each <ac>NVC</ac> category are MNN with ICA for <i>agree</i> and <i>thinking</i>, and HCRF for <i>question</i> and <i>understand</i>. MNN is poor for <i>question</i> <ac>NVC</ac> and HCRF is relatively poor for <i>thinking</i>. The method proposed in this chapter (<i>geometric-a</i>, SVM, see Table <ref label='TableCompareFeaturesAndClassifiers'/>) has an overall performance that is comparable with these non-fused approaches but is worse for <i>agree</i> than the temporal modelling approaches. Further tests would be required to establish statistical significance but it is likely that there is little difference in performance between these methods overall. Differences in specific <ac>NVC</ac> category performance may be due to:</p>

<ul>
<li>Each method uses a different representation of the face shape, with each being effective for recognizing a particular subset of <ac>NVC</ac> signals.</li>
<li>Temporal modelling may be beneficial for recognizing motion, such as nodding in <i>agree</i> which may account for its advantage in performance.</li>
<li>A <macro v='featureGeneration'/> approach may be advantageous if a particular <ac>NVC</ac> cannot be characterised by a consistent series of face shapes.</li>
</ul>

<p>The absence of performance improvement using temporal modelling is similar Petridis <macro v='etal'/> <cite ref='Petridis2009'/>, who concluded that while the field has moved towards “advanced data fusion methods relying on dynamic classifiers” for human behaviour recognition, the results from their experiments show that the supposed advantage of dynamic classifiers over static classifiers is “not straightforward and depends on the feature representation [...] and the task at hand”. In the context of their study, “HMMs does not seem to be beneficial, since it achieves the same performance as a static model”.
Also in the FERA2011 Facial Expression Recognition and Analysis Challenge <cite ref='Valstar2011'/>, Yang and Bhanu's approach was the most effective in both the person independent and overall evaluation and did not temporally model emotions but rather combined a video frames into an emotional avatar frame <cite ref='Yang2011'/>.
Hybrid approaches that combine dynamic and static classification were not used in this thesis but often have higher performance than non-hybrid methods. 
Interestingly, based on their BUHMAP based tests, Akakın and Sankur conclude that geometric features are superior to texture based features in both sequential and subspace classifiers. This finding concurs with the results presented in this chapter. 
Binary classification of clear examples of <ac>NVC</ac> is re-examined in Section <ref label='SectionDigestVectorOnClassification'/>.</p>

</section>
<section title="Conclusion">

<p>This chapter is a study of automatic classification for common, clear <ac>NVC</ac> signals in informal conversations. Various <macro v='featureGeneration'/> approaches are compared, as well as two classifiers. The best performance is achieved by a shape based geometric feature that exhaustively computes distances between pairs of trackers. 
However the method does not encode temporal information in the classifier model. Temporal encoding of feature variations using polynomial curve fitting was not found to increase performance significantly. Also, person specific normalisation of features was only applied to the algorithmic geometric features, and not to the other <macro v='featureGeneration'/> methods. Person specific normalisation should greatly benefit appearance features such as <ac>LBP</ac> because of the differences in facial appearance across different people can be removed and generalisation can be improved. Later chapters improve on the work here in that they have person specific normalisation applied uniformly to all <macro v='featureGeneration'/> methods.</p>

<p>In this study, shape is found to be more effective than appearance features, which agrees with similar findings in other papers <cite ref='Akakin2011'/> <cite ref='Lucey2009'/>, although some studies found appearance based features at least as significant <cite ref='Luettin1996'/> <cite ref='Valstar2011slides'/>.</p>

<p>The differences in cultural background in both the emotional encoders (the people who expressed the <ac>NVC</ac>) and the annotators (the people who perceived the <ac>NVC</ac>) is not considered. Cultural differences in <ac>NVC</ac> perception are revisited in Chapter <ref label='ChapterAnnotation'/>, in which <macro v='culturallySpecific'/> annotation data is collected. 
The next chapter attempts to create an <ac>NVC</ac> recognition system based on communication backchannel, which loosely speaking is a “<ac>NVC</ac> listener's” response to a communication event.</p>
</section>
</chapter>

